#! /bin/sh

case "$1" in
    '') name='intel_backlight';;
     *) name="$1";;
esac

path="/sys/class/backlight/$name"

current_state() {
        awk '
            FILENAME ~ "/max_brightness$" {max = $1; next}
            FILENAME ~     "/brightness$" {cur = $1; next}
            END                           {printf("(â˜€ %3d%%)\n", (cur / max) * 100)}
        ' \
        "$path/max_brightness" \
        "$path/brightness"
}

trap '' PIPE

current_state

# So technically, fswatch's poll_monitor just does a simple, periodic poll, as
# stated in the man page:
#
# > The poll monitor, a monitor which periodically stats the file system, saves
# > file modification times in memory and manually calculates file system
# > changes ...
#
# My thinking is that while it is still the same idea in principle, it is less
# work than us forking awk every second.
#
fswatch -m poll_monitor "$path/brightness" \
| while read -r _
do
    current_state
done
